package nuxeo

import (
	"strings"

	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"nuxeo-operator/pkg/apis/nuxeo/v1alpha1"
	"nuxeo-operator/pkg/util"
	"sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
)

// Configures Nginx as the reverse proxy by adding a sidecar Container and adding Volumes into the
// passed Deployment as specified in the passed Nginx rev proxy spec
func configureNginx(dep *appsv1.Deployment, nginx v1alpha1.NginxRevProxySpec) error {
	for _, vol := range nginxVolumes(nginx) {
		if err := util.OnlyAddVol(dep, vol); err != nil {
			return err
		}
	}
	return util.OnlyAddContainer(dep, nginxContainer(nginx))
}

// nginxContainer creates and returns a Container struct defining the Nginx reverse proxy. It defines various
// volume mounts which - therefore - must also be defined in the deployment that ultimately holds this container
// struct.
func nginxContainer(nginx v1alpha1.NginxRevProxySpec) corev1.Container {
	nginxImage := "nginx:latest"
	if nginx.Image != "" {
		nginxImage = nginx.Image
	}
	var pullPolicy = corev1.PullIfNotPresent
	if nginx.ImagePullPolicy == "" {
		if strings.HasSuffix(nginxImage, ":latest") {
			pullPolicy = corev1.PullAlways
		}
	} else {
		pullPolicy = nginx.ImagePullPolicy
	}
	c := corev1.Container{
		Name:            "nginx",
		Image:           nginxImage,
		ImagePullPolicy: pullPolicy,
		Ports: []corev1.ContainerPort{{
			Name:          "nginx-port",
			ContainerPort: 8443,
			Protocol:      "TCP",
		}},
		VolumeMounts: []corev1.VolumeMount{{
			Name:      "nginx-cert",
			ReadOnly:  true,
			MountPath: "/etc/secrets/",
		}, {
			Name:      "nginx-conf",
			ReadOnly:  true,
			MountPath: "/etc/nginx/",
		}, {
			Name:      "nginx-cache",
			ReadOnly:  false,
			MountPath: "/var/cache/nginx",
		}, {
			Name:      "nginx-tmp",
			ReadOnly:  false,
			MountPath: "/var/tmp",
		}},
	}
	return c
}

// nginxVolumes creates and returns a slice of Volume specs that support the VolumeMounts generated by the
// 'nginxContainer' function. Expectation is that these items will be added by the caller into a Deployment
func nginxVolumes(nginx v1alpha1.NginxRevProxySpec) []corev1.Volume {
	vols := []corev1.Volume{{
		Name: "nginx-conf",
		VolumeSource: corev1.VolumeSource{
			ConfigMap: &corev1.ConfigMapVolumeSource{
				LocalObjectReference: corev1.LocalObjectReference{Name: nginx.ConfigMap},
				DefaultMode:          util.Int32Ptr(420),
			},
		},
	}, {
		Name: "nginx-cert",
		VolumeSource: corev1.VolumeSource{
			Secret: &corev1.SecretVolumeSource{
				SecretName:  nginx.Secret,
				DefaultMode: util.Int32Ptr(420),
			},
		},
	}, {
		Name: "nginx-cache",
		VolumeSource: corev1.VolumeSource{
			EmptyDir: &corev1.EmptyDirVolumeSource{},
		},
	}, {
		Name: "nginx-tmp",
		VolumeSource: corev1.VolumeSource{
			EmptyDir: &corev1.EmptyDirVolumeSource{},
		},
	}}
	return vols
}

// If the configurer does not specify an nginx configmap then the operator will generate a default. This function
// creates a configmap in the cluster to support this. Also, since the configurer could edit the Nuxeo CR and explicitly
// specify a CM, this handles that case by removing the auto-generated configmap if it exists.
//
// Returns the name of the nginx configmap which could be the passed name, or the auto-generated name, and an error
// indicating any reconciliation errors (or nil)
func (r *ReconcileNuxeo) reconcileNginxCM(instance *v1alpha1.Nuxeo, configMapName string) (string, error) {
	defaultCmName := defaultNginxCMName(instance.Name)
	if configMapName == "" {
		cm := &corev1.ConfigMap{
			ObjectMeta: metav1.ObjectMeta{
				Name:      defaultCmName,
				Namespace: instance.Namespace,
			},
			Data: map[string]string{
				"nginx.conf": nginxConf,
				"proxy.conf": proxyConf,
			},
		}
		_ = controllerutil.SetControllerReference(instance, cm, r.scheme)
		_, err := r.addOrUpdate(cm.Name, instance.Namespace, cm, &corev1.ConfigMap{}, util.ConfigMapComparer)
		return defaultCmName, err
	} else {
		// configurer specified nginx configmap so - in case previously it was not specified and therefore
		// auto-generated, remove the auto-generated one if it exists
		return configMapName, r.removeIfPresent(instance, defaultCmName, instance.Namespace, &corev1.ConfigMap{})
	}
}

// generates a name for an auto-generated Nginx configuration ConfigMap in cases where the configurer did not
// provide a ConfigMap and therefore wants to use the auto-generated one
func defaultNginxCMName(instanceName string) string {
	return instanceName + "-nginx-config"
}

// nginxConf provides an auto-generated nginx.conf file
var nginxConf string = `
worker_processes  1;
error_log  /var/log/nginx/error.log warn;
pid        /var/cache/nginx/nginx.pid;

events {
	worker_connections  1024;
}

http {
	default_type  application/octet-stream;
	log_format json_combined escape=json
	  '{'
		'"time_local":"$time_local",'
		'"remote_addr":"$remote_addr",'
		'"remote_user":"$remote_user",'
		'"request":"$request",'
		'"status": "$status",'
		'"body_bytes_sent":"$body_bytes_sent",'
		'"request_time":"$request_time",'
		'"http_referrer":"$http_referer",'
		'"http_user_agent":"$http_user_agent"'
	  '}';

	access_log  /var/log/nginx/access.log  json_combined;

	proxy_cache_path        /var/cache/nginx levels=1:2 keys_zone=one:8m max_size=3000m inactive=600m;
	proxy_temp_path         /var/tmp;

	sendfile        on;
	#tcp_nopush     on;

	keepalive_timeout  65;

	gzip                    on;
	gzip_comp_level         6;
	gzip_vary               on;
	gzip_min_length         1000;
	gzip_proxied            any;
	gzip_types              text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;
	gzip_buffers 16 8k;

	client_max_body_size 20M;

	# per https://doc.nuxeo.com/nxdoc/http-and-https-reverse-proxy-configuration/#ngnix-issue
	ignore_invalid_headers off;

	include /etc/nginx/proxy.conf;
}`

// nginxConf provides an auto-generated proxy.conf file
var proxyConf string = `
server {
  listen 8443 default;

  ssl on;
  ssl_certificate /etc/secrets/tls.crt;
  ssl_certificate_key /etc/secrets/tls.key;
  ssl_dhparam /etc/secrets/dhparam;

  ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
  ssl_ciphers ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-RSA-RC4-SHA:AES128-GCM-SHA256:HIGH:!RC4:!MD5:!aNULL:!EDH:!CAMELLIA;
  ssl_prefer_server_ciphers on;

  ssl_session_cache shared:SSL:10m;
  ssl_session_timeout 10m;

  add_header Strict-Transport-Security max-age=15638400;
  add_header X-Frame-Options DENY;
  add_header X-Content-Type-Options nosniff;

  location / {
	  proxy_set_header        Host $host;
	  proxy_set_header        X-Real-IP $remote_addr;
	  proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;
	  proxy_set_header        X-Forwarded-Proto $scheme;
	  proxy_set_header        X-Forwarded-Host $http_host;
	  proxy_pass              http://localhost:8080;
	  proxy_read_timeout      90;
	  proxy_redirect          http:// https://;
	  proxy_http_version      1.1;
  }
}`
